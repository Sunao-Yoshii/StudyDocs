<!-- $theme: gaia -->

# 自動テストに移行するには

### 色々考えて意見も募ってみた

---

<!-- page_number: true -->

## お品書き

1. いまさら自動テストの利点
2. 最初に結論
3. 自動テストを阻害する要因と対処
3.1. 誤解による要因
3.2. 心理的要因
3.3. スキル的要因
3.4. 仕組み的要因
4. 最後に

---

#### 1. いまさら自動テストの利点

##### テスト自動化って言葉が出てもう１０年以上ですね

---

#### 1. いまさら自動テストの利点

何で今更？いえ、今だからこそです。

なんでこんな事を書くかと言うと、クラウド環境や変化の激しいプラットフォームにおいて、運用するだけでも互換の為の試験が発生するからです。

例えば非常に非常に簡単な一例を出します。

---

#### 1. いまさら自動テストの利点

**プラットフォームの変更に強い**

何を言っているかと言うと、安定安定と言われた Java が、半年ごとにバージョンアップを行い、どんどん EOL (殺害) すると言っています。  
LTS 版ですら最長で 3 年です。

つまり、３年に一度はどうあってもオーバーホールないしは互換テストをやらなければいけません。

これは一つ極端な例ですが、他にも

---

#### 1. いまさら自動テストの利点

**インクリメンタルに強い**

「クラウドに載せたら思ってたのと違う」ってありません？
昨今は運用プラットフォームもどんどん現れ、全部作って載せたら動かない…なんて悲惨な経験ありませんか？

このルネッサンス期では後戻りなんてザラに起こります。
小さく作ってバージョンを上げていく開発では、回帰試験は必須ですよね？

---

#### 1. いまさら自動テストの利点

**フレームワークのセキュリティパッチ**

昨今フレームワークのない開発なんてありえません。  
すると当然この問題が発生します。

動作をどう保証する？手でやる？本気ですか？

セキュリティは、攻撃ありきの進化なので、新しい攻撃が日時生まれてます。
こうしたことはいつまでも付きまといます。

---

#### 1. いまさら自動テストの利点

**メンバーの設計/コーディングスキル向上**

テストファーストを覚えることではありません。
テストコードを書くという事は、それが出来る設計を考えると言うことです。

もっと言うと、疎結合や、インターフェースの利用などといった変更、修正に強い設計に必然的に変わります。
（むしろ変えないとテスト書けないので、そういう実装に矯正されます）

---

#### 1. いまさら自動テストの利点

しかし欠点もあります。

* 製造と単体テストが不可分になる
* 高い確率で、設計、テストの教育コストがかかる
* プロジェクトの進め方を変える必要が出る

平たく言えば、運用変更と、なれるまでの導入コストがかかります。

---

#### 2. 最初に結論
##### 〜自動テストを運用するには〜

---

#### 2. 最初に結論

テスト自動化には以下が必要です

* テストコードを納品物件と指定すること
* 構造化に対応した設計手法に乗り換える事
* テスト可能な設計について、学習すること
* プロジェクト管理者を含め、システムの全体像を共有し、テストの妥当性をレビュー検証する事
* 品質会計等は、適用できるところだけにと割り切る

---

#### 2. 最初に結論

もっと言うと

**プロジェクト全体（管理者、品質管理、開発者、ライブラリアン等）で取り組むべき問題であり、開発者のみのセルフ改善として丸投げすれば必ず失敗、炎上します**

しかし、これをしなければ

**（環境を含む）変化に強いプロダクトを作ることはできません**

---

#### 3. 自動テストを阻害する要因と対処

---

#### 3.1. 誤解による要因

##### 「テストコードはコストがかかりすぎる！手でやった方がマシ！」は誤解

---

#### 3.1. 誤解による要因

よくみなさん単体試験と聞いて、テスト仕様書を Excel で書きますよね？  
テストデータをテーブルごとに定義して、「XX画面でYYしたらZZが表示される」とか…

でもまずそこから指摘です。

それは昨今単体テストとは呼びません。  
バッチで全てが解決した手続き時代の単体テストを、複雑化したこの時代に単体と呼んではいけません。  
それは **結合テスト** です。

---

#### 3.1. 誤解による要因

Wikipedia 様抜粋するも

> 手続き型プログラミングでは、ユニットは、モジュール全体のこともあるが、より一般的には、個々の関数や手続きである。オブジェクト指向プログラミングでは、ユニットは、クラスなどのインタフェース全体だが、個々のメソッドであることもある

とあります。  
もう一度言います、「ユニットとはクラスなどのインターフェース、もしくはここのメソッド」の事です。

---

#### 3.1. 誤解による要因

手動テストでも環境整備、事前データは大変でしょう？ましてコードにすると大変です。

**これが原因なのです。**

沢山の小さな機能の集合をテストしようとすれば、個々の機能に対して整合性のあるデータを作らなければいけません。

それではセットアップも増えますし、テストコードは書きにくいし、コストがかかります。


---

#### 3.1. 誤解による要因

たとえばアクセス制限のテストを考えたとして

ブラウザからログインしてX機能を呼ぶ…なんてテスト簡単に書けますか？

デザインが変わるかもしれないのに、ブラウザ操作を頑張りますか？

**私ならNOと答えます。誰だってNOと言います。**

でも分けてみるとどうでしょう？

---

#### 3.1. 誤解による要因

分割して見れば、個別にはテストコード書けそうではありませんか？

* アクセス判定を行ってるメソッドに、アカウントとURLを入れて true/false を確認
* (判定部分をモックで置き換えて)判定が false だったら「アクセス禁止」の画面HTMLを応答する。

---

#### 3.1. 誤解による要因

単体テストと言うのは、「機能を実現する為の個々の処理（部品）を個別に確認するもの」なのです。

ここを間違うと、単体テスト工数が跳ね上がります。

単体テストで個々の API が正しければ、結合さえ間違ってなければ正常動作するわけです。

---

#### 3.2. 心理的要因

##### よくわからないものに苦労はしたくない

---

#### 3.2. 心理的要因

やればわかります。
心理的に書きたくない人はとことんまで書きません。  
これは割と真面目な話としてです。

保守に関わらない開発メンバーにとっては、一旦は動くものができれば良いのです。  
保守しないのですから、テストコードの有り難みなんてわかりません。  
むしろ面倒で余計な作業と認識されます。

必須でなければ誰も書きません。

---

#### 3.2. 心理的要因要因

ではどうするか？

**最低限、正常系のテストコードは納品物と定義するのです。**

納品物なら書かない訳に行きません。  
また、正常系でもテストを書くと言うことは、仕様をあたらめて見直す機会でもあります。

テストを書く人は分かると思いますが、やってみると意外と未定義仕様に気付きます。
早い段階で潰しておけば、後工程のバグの発生は減ります。

---

#### 3.2. 心理的要因

懐疑的な人もいます。

*「プログラムがバグるのに、テストにバグがないわけないだろう」* 

もちろんバグります。

しかし、二重チェックなので両方噛み合わないとまずテストは失敗します。気づかないで後工程まで行くより良くないでしょうか？

---

#### 3.3. スキル的要因

##### なんとなくでは書けません

---

#### 3.3. スキル的要因

テストを書くと決まった時に、テストがセットアップで肥大化することって経験ありませんか？
実はこれはいくつか要因があるのです。

* テスト可能な粒度まで処理が分かれていない。
* 機能間がべったりくっついていて、個別にテストできない。

つまり **設計のスキルが要ります。**
スキルだけの問題でもないのですが、ここではまずスキルから見ましょう。

---

#### 3.3. スキル的要因

**テスト可能な粒度まで処理が分かれていない**

*詰め込みすぎです*

テストを前提とするなら、１メソッドの分岐&ループは 1-2 個までに抑えるべきです。

良く良く観察しましょう。

ループは意味のある処理単位ではないのでしょうか？  
それに名前を与えればメソッドになりませんか？

---

#### 3.3. スキル的要因

**機能間がべったりで、個別にテストできない**

クラス分離の粒度が悪いか、メソッド内でnewとかしてしまい、密結合しているかのどちらかです。  

他のオブジェクト参照はコンストラクタで行う、１クラス１目的を徹底するなどを行う必要があります。

また、関係するクラス数が多い場合は、そのクラスは何でも屋の可能性を疑いましょう。
（単なるハブの様な空っぽのクラスならかまわないですが）

---

#### 3.4. 仕組み的要因

##### 実は仕組みが一番問題

---

#### 3.4. 仕組み的要因

ここは最も重要な問題で

* 単体テストと開発が同時である
* 結局手動で網羅するならテストコードは廃れる
* 開発バグの統計とれなくない？
* 設計書のせいでテスト書けない！

なんて色々出てきます。

---

#### 3.4. 仕組み的要因

**単体テストと開発が同時である**

これをしないと、テストコードは不可能です。  
なぜか？

**同時でなければ、テスト可能なコードは書けません**

実装と別工程で書けるものでしょうか？
断言します、**テストが書けなくて製造に後戻りする** か、**大きなコストで無理やりテストするか** になります。
工程の後戻りがどれだけ大変か知らない訳ではないでしょう？

---

#### 3.4. 仕組み的要因

**結局手動で網羅するならテストコードは廃れる**

これはプロジェクトリーダーが、単体テストを適切に評価できない事に起因します。

* テストが全体のどの部分をさしているか理解できるようにする
* プロジェクトリーダーがテストレビューに参加し、テストの妥当性を確認する

最悪、もっと上位者がよくわかんないと言ったら終わりです（苦笑

---

#### 3.4. 仕組み的要因

*テストが全体のどの部分をさしているか理解できるようにする*

オススメの手段は、文章ではなく図として俯瞰できる設計書を起こす方法です。
Excel みたいなファイルが散らばっていては、一体どこを見れば良いのか全く分かりません。

図にしてしまえば、全体像を一発で俯瞰できます。
テストとのマッピングも「全体のうちのこの機能のこのモジュール」と言えれば、非常に分かりやすいです。

---

#### 3.4. 仕組み的要因

*プロジェクトリーダーがテストレビューに参加し、テストの妥当性を確認する*

意味合い的には品質を判定する方です。
この人がテストコードの妥当性を認識できないならそもそもテストコードをどれだけ書いても評価できません。

悪いことは言いません、協力が得られないならテストコードは強制しないほうが良いでしょう。

---

#### 3.4. 仕組み的要因

**開発バグの統計とれなくない？**

開発とか各段階で、開発規模に対して一定割合でバグがあるはず…という統計的な品質管理手法ができなくないか？という問題です。

結論するとできません。

テストファーストでは、最初は全てのテストが落ちます（だってそれが出発点なので）。
逆に、結合時点では既に全テストが OK になっているわけですから、統計も何もないのですね。

---

#### 3.4. 仕組み的要因

**開発バグの統計とれなくない？**

この考え方は、オブジェクト指向が広まり始めたあたりから、批判の対象でした。
ライブラリやコンポーネント、言語仕様が進化したことで、開発規模の個人差が非常に大きくなった事で、一律に数字を出せない為です。

設計の場所ではまだまだ活躍の余地あります。
しかし使う場合も、係数は変える必要もあり、実際の数字と予測値の乖離に悩むことになるでしょう。

---

#### 3.4. 仕組み的要因

**設計書のせいでテストが書けない**

日本語文章でつらつら手続きを書く仕様書。
果たしてこれで構造化プログラミングの設計が、現実的な工数で書けるのでしょうか？

未だかつてこんな仕様書でマトモなOOP設計見た事ないです。
メソッドを分けて外部参照するだけで、リンクを貼ったりと言った作業に見舞われます。

要するに構造化に対してメンテナンスが大変過ぎです

---

#### 3.4. 仕組み的要因

**設計書のせいでテストが書けない**

ではどう設計するのが良いのでしょう？

設計手法として、確立されてるやり方としては UML 等が挙げられます。
（昔ながらのExcel方眼紙が全てと思うな！
　そんなことしてるのは日本のみ！）

固執していないでいい加減目を向けるべきです。

---

#### 3.4. 仕組み的要因

**設計書のせいでテストが書けない**

良く、UML 等の批判に、「処理の行単位で書かない仕様書では、実装に個人差が出る」というものがあります。では―――

**中途半端に日本語で書いた文脈の解釈に個人差は出ないのですか？**
**その設計は 100% 動くコードに変換できるのですか？**

皆知ってるはずです。**「無理」** だと。

---

##### 補足①

では設計書はどの粒度にすればいいのか？ですが、UML の様な設計の思想で言えばこう考えます。

* クラスやコンポーネント、メソッドに一意の役割のみを与えよ
* メソッドはインプットとアウトプットを明確化する

IN/OUTが明確であれば、実装は個々で考えるべしという思想です。
逆に、明確化できないということは、メソッドに役割を持たせすぎです。保守不能メソッドは止めましょう

---

#### 補足②

**お勧めする設計法**

図で設計すれば、レビュー時も全体が見通せて便利です。
[かんたんUML](https://www.amazon.co.jp/exec/obidos/ASIN/477419039X/whiteazaleane-22/) （読破に２日かかりません）といった、老舗の設計方法がまずは良いかもしれません。

規模が小さく、お客様と同意が取れるなら、マインドマップで機能をプロット、メソッドまで派生させて行っても良いかもしれません。

---

#### 補足③

UML ツールは既に巷に数多く存在し、PDFなどに出せるものも少なくありません。

*  [AmaterasModeler](http://amateras.osdn.jp/cgi-bin/fswiki/wiki.cgi?page=AmaterasUML)
*  [draw.io](https://www.draw.io/)
*  [PlantUML](http://plantuml.com/)
*  [astah](http://astah.change-vision.com/ja/)

などなど、無料だけで結構な種類があります。
MS製品にこだわるなら、Visio ですらそうした図のサポートがあります。

---

#### 4. 最後に

ここまで書いた内容は、これまでのやり方を大きく否定しています。
つまり一種のパラダイムシフトです。

逆に、テストファーストが必要な求人は増えてます。
そろそろ生き残りをかけて踏み出す必要があるのではないでしょうか？

ここまでの内容、やり方が違うだけでやってみると初期導入コストが高いだけだったりします。
お試しでやってみませんか？

---

#### 4. おまけ

このPDF は Markdown で記述し、[Marp](https://yhatt.github.io/marp/) というツールでスライド化しました。
テキストに集中できるので、スラスラ書けたりしますので、割とオススメです。