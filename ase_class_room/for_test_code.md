<!-- $theme: gaia -->

# 自動テストに移行するには

### 色々考えて意見も募ってみた

---

<!-- page_number: true -->

## お品書き

1. いまさら自動テストの利点
2. 自動テストを阻害する要因と対処
2.1. 誤解による要因
2.2. 心理的要因
2.3. スキル的要因
2.4. 仕組み的要因
3. まとめ〜自動テストを運用するには〜

---

#### 1. いまさら自動テストの利点

##### テスト自動化って言葉が出てもう１０年以上ですね

---

#### 1. いまさら自動テストの利点

何で今更？いえ、今だからこそです。

なんでこんな事を書くかと言うと、クラウド環境や変化の激しいプラットフォームにおいて、運用するだけでも互換の為の試験が発生するからです。

例えば非常に非常に簡単な一例を出します。

---

#### 1. いまさら自動テストの利点

**Java の寿命は最長三年です**

何を言っているかと言うと、安定安定と言われた Java が、半年ごとにバージョンアップを行い、どんどん EOL (SATSUGAI) すると言っています。  
上記の 3 年は、LongTimeSupport 版で３年という意味なのです。

つまり、３年に一度はどう足掻いてもオーバーホールないしは互換テストをやらなければいけません。

これは一つ極端な例ですが、他にも

---

#### 1. いまさら自動テストの利点

**クラウドに載せたら思ってたのと違う**

新しいプラットフォームあるあるですね。  
昨今は運用プラットフォームもどんどん現れ、全部作って載せたら動かない…なんて悲惨な経験ありませんか？

このルネッサンス期では後戻りなんてザラに起こりますので、もういい加減一筆書きの WF が厳しくなっています。  
小さく作ってバージョンを上げていく開発では、回帰試験は必須ですよね？

---

#### 1. いまさら自動テストの利点

**フレームワークのセキュリティパッチ**

昨今フレームワークのない開発なんてありえません。  
すると当然この問題が発生します。

動作をどう保証する？手でやる？本気ですか？

セキュリティは、攻撃ありきの進化なので、新しい攻撃が日時生まれてるのでこう言うことはいつまでもあります。

---

#### 1. いまさら自動テストの利点

利点：

* 回帰試験実行コストの低減
* テストを実行する条件下で、少なくとも単体レベルで仕様通りに動く証明になる

欠点：

* 製造の一時コストは上がる
* 高い確率で、設計、テストの教育コストがかかる
* プロジェクトの進め方を変える必要が出る

---

## 設計/テストに教育はまだわかる。
## 進め方が変わるってどういうこと？
#### 説明はこの後で

---

#### 2. 自動テストを阻害する要因と対処

---

#### 2.1. 誤解による要因

##### 「テストコードはコストがかかりすぎる！手でやった方がマシ！」は誤解

---

#### 2.1. 誤解による要因

よくみなさん単体試験と聞いて、テスト仕様書を Excel で書きますよね？  
テストデータをテーブルごとに定義して、「XX画面でYYしたらZZが表示される」とか…

でもまずそこから指摘です。

それは昨今単体テストとは呼びません。  
バッチで全てが解決した手続き時代の単体テストを、複雑化したこの時代に単体と呼んではいけません。  
それは **結合テスト** です。

---

#### 2.1. 誤解による要因

Wikipedia 様抜粋するも

> 手続き型プログラミングでは、ユニットは、モジュール全体のこともあるが、より一般的には、個々の関数や手続きである。オブジェクト指向プログラミングでは、ユニットは、クラスなどのインタフェース全体だが、個々のメソッドであることもある

とあります。  
もう一度言います、「ユニットとはクラスなどのインターフェース、もしくはここのメソッド」の事です。

---

#### 2.1. 誤解による要因

実はこの辺がテスト準備が大きくなりすぎる問題に直結します。  
だって考えてみれば当然ですよね？

沢山の小さな機能の集まりをテストしようとすれば、個々の機能に対するデータを作らなければいけません。
それではセットアップも増えますし、テストコードは書きにくいし、コストがかかりますよ。

---

#### 2.1. 誤解による要因

たとえばアクセス制限のテストを考えたとして

ブラウザからログインしてX機能を呼ぶ…なんてテスト簡単に書けますか？

* アクセス判定を行ってるメソッドに、アカウントとURLを入れて OK/NG を確認
* (判定部分をモックで置き換えて)判定が NG だったら「アクセス禁止」の画面を応答する

って分ければなんかテストコード書けそうじゃないですか？

---

#### 2.1. 誤解による要因

つまり単体テストと言うのは、「機能を実現する為の個々の処理を個別に確認するもの」なのです。

ここを間違うと、単体テスト工数が跳ね上がりますのでご注意ください。

単体テストで個々の API が正しければ、結合さえ間違ってなければ正常動作するわけです。

---

#### 2.2. 心理的要因

---

#### 2.2. 心理的要因

やればわかります。  
テスト書いて来なかった人はテストをやりたがりません。

* メインコードがバグるのに、テストコードがバグらない訳ないではないか

論破そのものは簡単です。

両方意図通り動かないなら、ほぼ確実にテスト落ちますよね。  
二重チェックなのだから、むしろ気づいて良かったのでは？

---

#### 2.2. 心理的要因

とはいえ、心理的に書きたくない人はとことんまで書きません。  
これは割と真面目な話としてです。

保守に関わらない開発メンバーにとっては、一旦は動くものができれば良いのです。  
保守しないのですから、テストコードの有り難みなんてわかりません。  
むしろ面倒な余計な作業なのです。

必須でなければ誰も書きません。

---

#### 2.2. 心理的要因要因

ではどうするか？

**最低限正常系のテストコードは納品物と定義するのです。**

納品物なら書かない訳に行きません。  
また、正常系でもテストを書くと言うことは、仕様をあたらめて見直す機会でもあります。

テストを書く人は分かると思いますが、やってみると意外と未定義仕様が出てきます。  
早い段階で潰しておけば、バグの発生は減ります。

---

#### 2.3. スキル的要因
##### なんとなくで書けるモンじゃない

---

#### 2.3. スキル的要因

テストを書くと決まった時に、テストがセットアップで肥大化することって経験ありませんか？  
実はこれはいくつか要因があるのです。

* テスト可能な粒度まで処理が分かれていない。
  (もっと言うと、メソッドに詰め込みすぎ)
* 機能間がべったりくっついていて、個別にテストできない。

これまた、テストあるあるです。  
スキルだけの問題でもないのですが、ここではまずスキルから見ましょう。

---

#### 2.3. スキル的要因

**テスト可能な粒度まで処理が分かれていない**

一言で言い切れるレベルで処理は分割すべきでしょう。  
テストを前提とするなら、１メソッドの分岐&ループは 1-2 個までに抑えるべきです。

良く良く観察しましょう。

ループは意味のある処理単位ではないのでしょうか？  
それに名前を与える事が抽象化というものです。

---

#### 2.3. スキル的要因

**能間がべったりで、個別にテストできない**

クラス分離の粒度が悪いか、メソッド内でnewとかしてるのどちらかです。  
他のオブジェクト参照はコンストラクタで行う、１クラス１目的を徹底するなどを行う必要があります。

その辺りはどちらかといえば定石の問題ですので、「プリンシプル・オブ・プログラミング」などをオススメします。  
安直には、**単一責任の原則** などを調べて見ても良いでしょう。

---

#### 2.4. 仕組み的要因

##### 実は仕組みが一番問題

---

#### 2.4. 仕組み的要因

ここは最も重要な問題で

* テストと開発が同時である事をWFが想定してない
* 結局手動で網羅するならテストコード無駄だよね
* 品質会計載せれないでしょ
* 設計書のせいでテスト書けない！

なんて色々出てきます。

---

#### 2.4. 仕組み的要因

**テストと開発が同時である事をWFが想定してない**

これをしないと、テストコードは不可能です。  
なぜか？

**同時でなければ、テスト可能なコードは書けません**

実装とほぼ同時に書かずに、後から書けるものでしょうか？  
テストをどう書けば良いか分からないまま実装したコードに後だしでテストなんて書ける訳がないのです。

---

#### 蛇足

理想はテストファーストで、アジャイルコンソーシアム（アジャイルの試験問題を作ってるフォーラム）では、もはや常識です。  
テストファーストしないと崩壊するとまで言われてます。

---

#### 2.4. 仕組み的要因

**結局手動で網羅するならテストコード無駄だよね**

これはプロジェクトリーダーが、単体テストを適切に評価できない事に起因します。

* テストが全体のどの部分をさしているか理解できるようにする
* プロジェクトリーダーがテストレビューに参加し、テストの妥当性を確認する

最悪、もっと上位者がよくわかんないと言ったら終わりです（苦笑

---

#### 2.4. 仕組み的要因

*テストが全体のどの部分をさしているか理解できるようにする*

オススメの手段は、文章ではなく図として設計書を起こす方法です。  
Excel みたいなファイルが散らばっていては、一体どこを見れば良いのか全く分かりません。

図にしてしまえば、全体像を一発で俯瞰できます。  
テストとのマッピングも「全体のうちのこのこの機能のこのモジュール」と言えれば、非常に分かりやすいです。

---

#### 2.4. 仕組み的要因

*プロジェクトリーダーがテストレビューに参加し、テストの妥当性を確認する*

意味合い的には品質を判定する方です。  
この人がテストコードの妥当性を認識できないならそもそもテストコードをどれだけ書いても評価されません。

悪いことは言いません、これに当たるならテストコードは強制しないほうが良いでしょう。


---

#### 2.4. 仕組み的要因

**品質会計載せれないでしょ**

「はっはー載せれませんね」と割り切りましょう。

テストファーストでは、最初は全てのテストが落ちます。（だってそれが出発点なので）  
逆に、結合時点では既に全テストが OK になっているわけですから、品質会計も何もないのですね。

品質会計の発想は悪くありません。  
単体はまだしも、結合・運用はまだまだ現役です。  
単体に限ってはその役目を終えたと見ると気が楽です。

---

#### 2.4. 仕組み的要因

**設計書のせいでテストが書けない**

個人的にはこれが最大。  
Excel で設計なんてしてると、手続きしか書かなくなるんです。

メソッド分けるとシートが増えるし、クラスが増えるとExcelが増える…。  
これに対して、オブジェクト指向を真面目にやれば１プロジェクト 100 クラスごとき一瞬です。

オブジェクト指向の設計手法が殆ど図であるのは、この辺りから来ています。

---

#### 2.4. 仕組み的要因

ではどう設計する？  
真面目に考えるなら UML で書くべきでしょう。  
UML 1.0 と違い、UML 2.5 ではだいぶ初見でも見やすくなりました。

この辺りは [かんたんUML](https://www.amazon.co.jp/exec/obidos/ASIN/477419039X/whiteazaleane-22/) などの本は非常に分かりやすいので、オススメできます。

ちなみに、お客様がそこまで拘っていないのであれば、個人的には MindMap で書くのをオススメします。

---

#### 3. まとめ
##### 〜自動テストを運用するには〜

---

#### 3. まとめ

つまりテスト自動化には以下が必要です

* テストコードを納品物件と指定すること
* オブジェクト指向な設計手法に乗り換える事
* テスト可能な設計について、学習すること
* プロジェクト管理者を含め、システムの全体像を共有し、テストの妥当性をレビュー検証する事
* 品質会計といった、手続き型に特化したノウハウを無理に適用せず、適用できるところだけにと割り切る

---

#### 3. まとめ

ここまで書いた内容は、これまでのやり方を大きく否定しています。
つまり一種のパラダイムシフトです。

逆に、求人でもテストファーストが当たり前な中小企業は増えてきました。
そろそろ生き残りをかけて踏み出す必要があるのではないでしょうか？

しかし、ここまでの内容、やり方が違うだけでやってみると初期導入コストが高いだけだったりします。
お試しでやってみませんか？

---

#### 4. おまけ

このPDF は Markdown で記述し、[Marp](https://yhatt.github.io/marp/) というツールでスライド化しました。
テキストに集中できるので、スラスラ書けたりしますので、割とオススメです。